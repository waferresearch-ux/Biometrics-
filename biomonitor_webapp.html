<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BioMonitor - Real-time Biometric Data Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(to right, #fff, #64b5f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #44ff44;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        #calibrateStepsBtn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        #calibrateStepsBtn:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metric-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #64b5f6;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(to right, #fff, #64b5f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .metric-unit {
            font-size: 0.8em;
            color: #999;
            margin-left: 5px;
        }

        .metric-subtitle {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }

        .walking-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
            margin-left: 10px;
            animation: none;
        }

        .walking-indicator.active {
            background: #44ff44;
            animation: pulse 1s infinite;
        }

        .chart-container {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .chart-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #64b5f6;
            text-align: center;
        }

        canvas {
            max-height: 300px;
        }

        .activity-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .activity-idle { background: rgba(128,128,128,0.3); }
        .activity-walking { background: rgba(76,175,80,0.3); }
        .activity-running { background: rgba(255,152,0,0.3); }
        .activity-sport { background: rgba(244,67,54,0.3); }

        .stress-bar {
            width: 100%;
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
        }

        .stress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #FFC107, #F44336);
            width: 0%;
            transition: width 0.5s ease;
        }

        .log-container {
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            color: #0f0;
            border: 1px solid #333;
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.success {
            color: #44ff44;
        }

        .log-entry.warning {
            color: #ffaa44;
        }

        .calibration-status {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 10px;
            text-align: center;
            font-weight: 500;
        }

        .calibration-status.active {
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            h1 {
                font-size: 2em;
            }
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>BioMonitor Dashboard</h1>
            <p style="color: #b3d9ff;">Real-time Biometric Data Visualization</p>
        </header>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Disconnected</span>
            </div>
            <div class="status-indicator">
                <span>Device: <strong id="deviceName">--</strong></span>
            </div>
            <div class="status-indicator">
                <span>Battery: <strong id="batteryLevel">--%</strong> (<span id="batteryVoltage">--V</span>)</span>
            </div>
        </div>

        <div class="controls">
            <button id="connectBtn">Connect to Device</button>
            <button id="calibrateStepsBtn" disabled>üö∂ Calibrate Steps</button>
            <button id="resetStepsBtn" disabled>Reset Steps</button>
            <button id="resetCaloriesBtn" disabled>Reset Calories</button>
            <button id="calibrateGsrBtn" disabled>Calibrate GSR</button>
            <button id="exportDataBtn" disabled>Export Data</button>
        </div>

        <div class="calibration-status" id="calibrationStatus">
            <span id="calibrationMessage">Calibration in progress...</span>
        </div>

        <div class="dashboard">
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">‚ù§Ô∏è Heart Rate</span>
                    <span class="metric-value" id="heartRate">--<span class="metric-unit">BPM</span></span>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">üíì HRV</span>
                    <span class="metric-value" id="hrv">--<span class="metric-unit">ms</span></span>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">üå°Ô∏è Temperature</span>
                    <span class="metric-value" id="temperature">--<span class="metric-unit">¬∞C</span></span>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">üí¶ GSR</span>
                    <span class="metric-value" id="gsr">--<span class="metric-unit">ŒºS</span></span>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">üèÉ Activity</span>
                    <span class="activity-indicator" id="activity">--</span>
                </div>
                <div>
                    Steps: <strong id="steps">0</strong>
                    <span class="walking-indicator" id="walkingIndicator"></span>
                </div>
                <div>Calories: <strong id="calories">0</strong> kcal</div>
                <div class="metric-subtitle" id="cadenceInfo">Cadence: -- steps/min</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-title">üòì Stress Level</span>
                    <span class="metric-value" id="stressPercent">--%</span>
                </div>
                <div class="stress-bar">
                    <div class="stress-fill" id="stressFill"></div>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-title">Heart Rate & HRV</div>
            <canvas id="heartChart"></canvas>
        </div>

        <div class="chart-container">
            <div class="chart-title">GSR & Temperature</div>
            <canvas id="gsrTempChart"></canvas>
        </div>

        <div class="chart-container">
            <div class="chart-title">Activity & Stress</div>
            <canvas id="activityChart"></canvas>
        </div>

        <div class="chart-container">
            <div class="chart-title">Debug Log</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

    <script>
        // Global variables
        let device = null;
        let biometricCharacteristic = null;
        let voltageCharacteristic = null;
        let commandCharacteristic = null;
        let dataBuffer = [];
        let maxDataPoints = 50;
        
        // Multi-packet data handling
        let packetBuffer = [];
        let packetTimeout = null;
        const PACKET_TIMEOUT_MS = 500; // Wait up to 500ms for all packets
        
        // Step tracking
        let currentSteps = 0;
        let walkingDetected = false;
        let lastStepUpdate = Date.now();

        // Chart.js setup
        Chart.defaults.color = '#999';
        Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 500
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(255,255,255,0.1)'
                    }
                },
                y: {
                    grid: {
                        color: 'rgba(255,255,255,0.1)'
                    }
                }
            }
        };

        // Initialize charts
        const heartChart = new Chart(document.getElementById('heartChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Heart Rate (BPM)',
                    data: [],
                    borderColor: '#ff4444',
                    backgroundColor: 'rgba(255,68,68,0.1)',
                    tension: 0.4,
                    yAxisID: 'y'
                }, {
                    label: 'HRV (ms)',
                    data: [],
                    borderColor: '#44ff44',
                    backgroundColor: 'rgba(68,255,68,0.1)',
                    tension: 0.4,
                    yAxisID: 'y1'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false,
                            color: 'rgba(255,255,255,0.1)'
                        }
                    }
                }
            }
        });

        const gsrTempChart = new Chart(document.getElementById('gsrTempChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'GSR (ŒºS)',
                    data: [],
                    borderColor: '#4444ff',
                    backgroundColor: 'rgba(68,68,255,0.1)',
                    tension: 0.4,
                    yAxisID: 'y'
                }, {
                    label: 'Temperature (¬∞C)',
                    data: [],
                    borderColor: '#ff9800',
                    backgroundColor: 'rgba(255,152,0,0.1)',
                    tension: 0.4,
                    yAxisID: 'y1'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false,
                            color: 'rgba(255,255,255,0.1)'
                        }
                    }
                }
            }
        });

        const activityChart = new Chart(document.getElementById('activityChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Stress Level (%)',
                    data: [],
                    borderColor: '#e91e63',
                    backgroundColor: 'rgba(233,30,99,0.1)',
                    tension: 0.4,
                    yAxisID: 'y'
                }, {
                    label: 'Steps',
                    data: [],
                    borderColor: '#00bcd4',
                    backgroundColor: 'rgba(0,188,212,0.1)',
                    tension: 0.4,
                    yAxisID: 'y1'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        min: 0,
                        max: 100,
                        grid: {
                            color: 'rgba(255,255,255,0.1)'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false,
                            color: 'rgba(255,255,255,0.1)'
                        }
                    }
                }
            }
        });

        // Logging function
        function log(message, type = 'normal') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = type === 'error' ? 'log-entry error' : 
                             type === 'success' ? 'log-entry success' : 
                             type === 'warning' ? 'log-entry warning' : 'log-entry';
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Calculate battery percentage based on actual device behavior
        function calculateBatteryPercentage(voltage) {
            // Based on actual device: 3.20V = 100% (full battery)
            // 2.80V = 0% (estimated cutoff)
            
            if (voltage >= 3.20) {
                return 100;
            } else if (voltage >= 3.10) {
                return Math.round(85 + (voltage - 3.10) * 150); // 85-100%
            } else if (voltage >= 3.00) {
                return Math.round(65 + (voltage - 3.00) * 200); // 65-85%
            } else if (voltage >= 2.95) {
                return Math.round(40 + (voltage - 2.95) * 500); // 40-65%
            } else if (voltage >= 2.90) {
                return Math.round(20 + (voltage - 2.90) * 400); // 20-40%
            } else if (voltage >= 2.85) {
                return Math.round(10 + (voltage - 2.85) * 200); // 10-20%
            } else if (voltage >= 2.80) {
                return Math.round(5 + (voltage - 2.80) * 100); // 5-10%
            } else {
                return 5; // Minimum 5%
            }
        }

        // Connect to device
        async function connectToDevice() {
            try {
                log('Requesting Bluetooth device...');
                device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [
                        '00000001-710e-4a5b-8d75-3e5b444bc3cf',
                        '0000181a-0000-1000-8000-00805f9b34fb' // Environmental sensing service (full UUID)
                    ]
                });

                log(`Connecting to ${device.name}...`);
                const server = await device.gatt.connect();
                
                log('Getting primary service...');
                const service = await server.getPrimaryService('00000001-710e-4a5b-8d75-3e5b444bc3cf');
                
                log('Getting characteristics...');
                biometricCharacteristic = await service.getCharacteristic('00001001-710e-4a5b-8d75-3e5b444bc3cf');
                voltageCharacteristic = await service.getCharacteristic('00002001-710e-4a5b-8d75-3e5b444bc3cf');
                commandCharacteristic = await service.getCharacteristic('00003001-710e-4a5b-8d75-3e5b444bc3cf');
                
                // Set up notifications
                log('Setting up notifications...');
                await biometricCharacteristic.startNotifications();
                biometricCharacteristic.addEventListener('characteristicvaluechanged', handleBiometricData);
                
                // Note: Voltage characteristic might not send notifications anymore
                // since voltage is included in biometric data packets
                try {
                    await voltageCharacteristic.startNotifications();
                    voltageCharacteristic.addEventListener('characteristicvaluechanged', handleVoltageData);
                } catch (error) {
                    log('Voltage notifications not available (this is normal)', 'warning');
                }
                
                // Update UI
                document.getElementById('connectionStatus').classList.add('connected');
                document.getElementById('connectionText').textContent = 'Connected';
                document.getElementById('deviceName').textContent = device.name || 'BioMonitor';
                document.getElementById('connectBtn').textContent = 'Disconnect';
                
                // Enable control buttons
                document.querySelectorAll('button:not(#connectBtn)').forEach(btn => {
                    btn.disabled = false;
                });
                
                log('Connected successfully!', 'success');
                
                // Set up disconnect handler
                device.addEventListener('gattserverdisconnected', onDisconnected);
                
            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                console.error('Connection error:', error);
            }
        }

        // Handle disconnection
        function onDisconnected() {
            log('Device disconnected', 'warning');
            
            // Update UI
            document.getElementById('connectionStatus').classList.remove('connected');
            document.getElementById('connectionText').textContent = 'Disconnected';
            document.getElementById('deviceName').textContent = '--';
            document.getElementById('connectBtn').textContent = 'Connect to Device';
            document.getElementById('batteryLevel').textContent = '--%';
            document.getElementById('batteryVoltage').textContent = '--V';
            
            // Disable control buttons
            document.querySelectorAll('button:not(#connectBtn)').forEach(btn => {
                btn.disabled = true;
            });
            
            // Reset walking indicator
            document.getElementById('walkingIndicator').classList.remove('active');
            
            device = null;
        }

        // Handle biometric data
        function handleBiometricData(event) {
            const decoder = new TextDecoder();
            const data = decoder.decode(event.target.value);
            
            // Add to packet buffer (accumulate fragments)
            packetBuffer.push(data);
            
            // Clear any existing timeout
            if (packetTimeout) {
                clearTimeout(packetTimeout);
            }
            
            // Set timeout to process packets
            packetTimeout = setTimeout(() => {
                processPackets();
            }, PACKET_TIMEOUT_MS);
        }
        
        // Process accumulated packets
        function processPackets() {
            if (packetBuffer.length === 0) return;
            
            // Combine all packet fragments into one string
            const combinedString = packetBuffer.join('');
            log(`Received data: ${combinedString}`);
            
            // Clear packet buffer
            packetBuffer = [];
            
            // Try to find and parse complete JSON objects
            const jsonObjects = extractJsonObjects(combinedString);
            
            // Merge all found objects
            let combinedData = {};
            for (const obj of jsonObjects) {
                Object.assign(combinedData, obj);
            }
            
            // Update UI with combined data
            if (Object.keys(combinedData).length > 0) {
                updateMetrics(combinedData);
                updateCharts(combinedData);
                
                // Log which data types were received
                const dataTypes = Object.keys(combinedData).join(', ');
                log(`Data processed: ${dataTypes}`);
                
                // Update walking indicator if we have step data
                if (combinedData.steps !== undefined) {
                    updateWalkingIndicator();
                }
            }
        }
        
        // Extract complete JSON objects from a string that may contain multiple objects
        function extractJsonObjects(str) {
            const objects = [];
            let depth = 0;
            let start = -1;
            
            for (let i = 0; i < str.length; i++) {
                if (str[i] === '{') {
                    if (depth === 0) {
                        start = i;
                    }
                    depth++;
                } else if (str[i] === '}') {
                    depth--;
                    if (depth === 0 && start !== -1) {
                        const jsonStr = str.substring(start, i + 1);
                        try {
                            const obj = JSON.parse(jsonStr);
                            objects.push(obj);
                        } catch (error) {
                            log(`Failed to parse JSON: ${jsonStr}`, 'error');
                        }
                        start = -1;
                    }
                }
            }
            
            return objects;
        }

        // Handle voltage data
        function handleVoltageData(event) {
            const decoder = new TextDecoder();
            const data = decoder.decode(event.target.value);
            
            try {
                const json = JSON.parse(data);
                if (json.percent !== undefined) {
                    document.getElementById('batteryLevel').textContent = `${json.percent}%`;
                }
                if (json.voltage !== undefined) {
                    document.getElementById('batteryVoltage').textContent = `${json.voltage.toFixed(2)}V`;
                }
            } catch (error) {
                log(`Error parsing voltage data: ${error.message}`, 'error');
            }
        }

        // Update metrics display
        function updateMetrics(data) {
            if (data.hr !== undefined) {
                document.getElementById('heartRate').innerHTML = `${Math.round(data.hr)}<span class="metric-unit">BPM</span>`;
            }
            if (data.hrv !== undefined) {
                document.getElementById('hrv').innerHTML = `${data.hrv.toFixed(1)}<span class="metric-unit">ms</span>`;
            }
            if (data.temp !== undefined) {
                document.getElementById('temperature').innerHTML = `${data.temp.toFixed(1)}<span class="metric-unit">¬∞C</span>`;
            }
            if (data.gsr !== undefined) {
                document.getElementById('gsr').innerHTML = `${data.gsr.toFixed(2)}<span class="metric-unit">ŒºS</span>`;
            }
            if (data.stress !== undefined) {
                const stressPercent = Math.round(data.stress * 100);
                document.getElementById('stressPercent').textContent = `${stressPercent}%`;
                document.getElementById('stressFill').style.width = `${stressPercent}%`;
            }
            if (data.activity !== undefined) {
                const activityEl = document.getElementById('activity');
                activityEl.textContent = data.activity;
                activityEl.className = `activity-indicator activity-${data.activity}`;
                
                // Update walking status
                walkingDetected = (data.activity === 'walking' || data.activity === 'running');
            }
            if (data.steps !== undefined) {
                currentSteps = data.steps;
                document.getElementById('steps').textContent = data.steps;
                lastStepUpdate = Date.now();
                
                // Calculate and display cadence
                if (walkingDetected) {
                    calculateCadence(data);
                }
            }
            if (data.calories !== undefined) {
                document.getElementById('calories').textContent = data.calories.toFixed(1);
            }
            // Handle voltage/battery from biometric data
            if (data.voltage !== undefined) {
                // Use the proper battery percentage calculation
                const batteryPercent = calculateBatteryPercentage(data.voltage);
                document.getElementById('batteryLevel').textContent = `${batteryPercent}%`;
                document.getElementById('batteryVoltage').textContent = `${data.voltage.toFixed(2)}V`;
            }
        }
        
        // Update walking indicator
        function updateWalkingIndicator() {
            const indicator = document.getElementById('walkingIndicator');
            const timeSinceLastStep = Date.now() - lastStepUpdate;
            
            // Show active indicator if walking detected and recent step update
            if (walkingDetected && timeSinceLastStep < 3000) {
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
        }
        
        // Calculate and display cadence
        let stepHistory = [];
        function calculateCadence(data) {
            if (data.steps !== undefined) {
                const now = Date.now();
                stepHistory.push({ steps: data.steps, time: now });
                
                // Keep only last 30 seconds of data
                stepHistory = stepHistory.filter(entry => now - entry.time < 30000);
                
                if (stepHistory.length >= 2) {
                    const oldestEntry = stepHistory[0];
                    const newestEntry = stepHistory[stepHistory.length - 1];
                    const stepDiff = newestEntry.steps - oldestEntry.steps;
                    const timeDiff = (newestEntry.time - oldestEntry.time) / 1000 / 60; // minutes
                    
                    if (timeDiff > 0) {
                        const cadence = Math.round(stepDiff / timeDiff);
                        document.getElementById('cadenceInfo').textContent = `Cadence: ${cadence} steps/min`;
                    }
                }
            }
        }

        // Update charts
        function updateCharts(data) {
            const timestamp = new Date().toLocaleTimeString();
            
            // Add timestamp to all charts
            if (heartChart.data.labels.length >= maxDataPoints) {
                heartChart.data.labels.shift();
                heartChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            heartChart.data.labels.push(timestamp);
            
            if (gsrTempChart.data.labels.length >= maxDataPoints) {
                gsrTempChart.data.labels.shift();
                gsrTempChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            gsrTempChart.data.labels.push(timestamp);
            
            if (activityChart.data.labels.length >= maxDataPoints) {
                activityChart.data.labels.shift();
                activityChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            activityChart.data.labels.push(timestamp);
            
            // Update heart chart
            if (data.hr !== undefined) {
                heartChart.data.datasets[0].data.push(data.hr);
            }
            if (data.hrv !== undefined) {
                heartChart.data.datasets[1].data.push(data.hrv);
            }
            
            // Update GSR/Temp chart
            if (data.gsr !== undefined) {
                gsrTempChart.data.datasets[0].data.push(data.gsr);
            }
            if (data.temp !== undefined) {
                gsrTempChart.data.datasets[1].data.push(data.temp);
            }
            
            // Update activity chart
            if (data.stress !== undefined) {
                activityChart.data.datasets[0].data.push(data.stress * 100);
            }
            if (data.steps !== undefined) {
                activityChart.data.datasets[1].data.push(data.steps);
            }
            
            // Update all charts
            heartChart.update('none');
            gsrTempChart.update('none');
            activityChart.update('none');
            
            // Store data for export
            dataBuffer.push({ timestamp, ...data });
            if (dataBuffer.length > 1000) dataBuffer.shift();
        }

        // Send command to device
        async function sendCommand(command) {
            if (!commandCharacteristic) {
                log('Not connected to device', 'error');
                return;
            }
            
            try {
                const encoder = new TextEncoder();
                await commandCharacteristic.writeValue(encoder.encode(command));
                log(`Command sent: ${command}`, 'success');
            } catch (error) {
                log(`Error sending command: ${error.message}`, 'error');
            }
        }

        // Calibrate steps
        async function calibrateSteps() {
            const statusDiv = document.getElementById('calibrationStatus');
            const messageSpan = document.getElementById('calibrationMessage');
            
            statusDiv.classList.add('active');
            messageSpan.textContent = 'Starting calibration - please remain still...';
            
            await sendCommand('calibrate_steps');
            
            // Update status after 1 second
            setTimeout(() => {
                messageSpan.textContent = 'Baseline recorded - now walk in place when the device LED turns green...';
            }, 1000);
            
            // Update status after 3 seconds
            setTimeout(() => {
                messageSpan.textContent = 'Recording walking pattern - keep walking...';
            }, 3000);
            
            // Hide status after 6 seconds
            setTimeout(() => {
                messageSpan.textContent = 'Calibration complete!';
                setTimeout(() => {
                    statusDiv.classList.remove('active');
                }, 2000);
            }, 6000);
        }

        // Export data
        function exportData() {
            const csvContent = "data:text/csv;charset=utf-8," 
                + "Timestamp,Heart Rate,HRV,Temperature,GSR,Stress,Activity,Steps,Calories,Battery Voltage,Battery %\n"
                + dataBuffer.map(row => 
                    `${row.timestamp},${row.hr || ''},${row.hrv || ''},${row.temp || ''},${row.gsr || ''},${row.stress || ''},${row.activity || ''},${row.steps || ''},${row.calories || ''},${row.voltage || ''},${row.voltage ? calculateBatteryPercentage(row.voltage) : ''}`
                ).join("\n");
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `biomonitor_data_${new Date().toISOString()}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            log('Data exported successfully', 'success');
        }

        // Event listeners
        document.getElementById('connectBtn').addEventListener('click', async () => {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            } else {
                await connectToDevice();
            }
        });

        document.getElementById('calibrateStepsBtn').addEventListener('click', calibrateSteps);

        document.getElementById('resetStepsBtn').addEventListener('click', () => {
            sendCommand('reset_steps');
            currentSteps = 0;
            stepHistory = [];
            document.getElementById('steps').textContent = '0';
            document.getElementById('cadenceInfo').textContent = 'Cadence: -- steps/min';
        });

        document.getElementById('resetCaloriesBtn').addEventListener('click', () => {
            sendCommand('reset_calories');
        });

        document.getElementById('calibrateGsrBtn').addEventListener('click', () => {
            sendCommand('calibrate_gsr');
        });

        document.getElementById('exportDataBtn').addEventListener('click', exportData);

        // Check for Web Bluetooth support
        if (!navigator.bluetooth) {
            log('Web Bluetooth is not supported in this browser', 'error');
            document.getElementById('connectBtn').disabled = true;
        } else {
            log('Web Bluetooth is supported. Ready to connect.');
        }
        
        // Update walking indicator periodically
        setInterval(updateWalkingIndicator, 1000);
    </script>
</body>
</html>